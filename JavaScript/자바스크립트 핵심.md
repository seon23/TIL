
# 자바스크립트(Javascript)
실시간 모니터링 시스템을 만들며 정복하는 MEVN의 2장을 참고하여 정리

<br>

[1. 함수 스코프와 호이스팅](#1-함수-스코프와-호이스팅)<br>
관련 내용을 용어별로 정리하였다.
- [자바스크립트](#자바스크립트)
- [ECMA](#ECMA)
- [var 변수 선언](#var-변수-선언)
- [`let` 변수 / `const` 상수 선언](#let-변수--const-상수-선언)
- [스코프](#스코프)
- [호이스팅](#호이스팅)
- [var과 let, const](#var과-let-const)
- [선언](#선언)
- [TDZ](#tdz)
- [초기화](#초기화)

<br>

[2. 화살표함수와 기본 매개변수](#2-화살표함수와-기본-매개변수)
- [화살표 함수](#화살표-함수)
- [기본 매개변수](#기본-매개변수)

<br>

[3. 배열 관련 대표 함수](#3-배열-관련-대표-함수)


<br>

## 1. 함수 스코프와 호이스팅
### 자바스크립트
- 인터프리터 기반의 동적 타입 언어
- 매년 발전 과정을 ES2015(ES6), ES2016(ES7) 등의 명칭으로 지정
    - ES6: ES2015 이후의 자바스크립트 문법
- ES5에서는 `var`로 변수 선언 → 함수 스코프, 호이스팅으로 인해 예상치 못한 버그 발생 → 때문에 ES6에서는 상수, 변수를 각각 `const`, `let` 키워드로 선언<br>
### ECMA
> ECMA 스크립트:<br>
ECMA-262 기술규격에 따라 정의하는 표준화된 스크립트 프로그래밍 언어. 자바스크립트 표준화 목적으로 제정<br>

<br>

### `var` 변수 선언
```
function b(){
    var i = 3;
    for(var i = 0; i < 10; i++){
    }
    return i;
}
console.log(b())    // 10
```
결과 설명
- 3이 아닌 10을 반환
- for문 안에서 `var`로 선언한 i는 함수 b()에서만 접근 가능(함수 [스코프](#스코프))
- 이는 미리 선언된 i를 재할당한 셈이다.([호이스팅](#호이스팅) 때문)

<br>

```
function b(){
    for(var i = 0; i < 10; i++){
    }
    return i;
    }
console.log(b())    // 10
```
결과 설명
- `var`로 변수 선언 → 함수 스코프 → b() 함수의 최상단으로 호이스팅
- 따라서 i는 for문에서 선언했지만 블록 밖에서도 참조 가능

<br>

### `let` 변수 / `const` 상수 선언
```
function b() {
    for(let i = 0; i < 10; i++){
    }
    return i;
}
console.log(b()) // Reference Error: i is not defined
```
`let`으로 변수 선언 → 블록 스코프, {} 안에서만 접근 가능<br>
<br>

### 스코프
변수의 접근성을 책임지는 보호막

- `var`로 변수 선언하면 함수 안에서 접근 가능 (함수 스코프)
- `let`, `const`로 선언하면 블록{} 안에서 접근 가능 (블록 스코프)

<br>

### 호이스팅
모든 함수, 변수가 선언될 때 스코프의 ~~최상단으로 이동하는 것~~ 최상단에서 선언된 것처럼 동작하는 것

#### const, let의 호이스팅
const, let으로 선언해도 호이스팅은 일어난다.<br>
```
let a = 1;
if(true){
    console.log(a)
    let a = 2
}
```
결과: **Uncaught ReferenceError: Cannot access 'a' before initialization**
- 왜 `undefined`가 아니라 `초기화 이전에 접근 불가`일까?
    - 호이스팅 발생 → `let a = 2`이 if 블록 최상단에서 [선언](#선언)된 것처럼 동작 → [TDZ](#tdz)으로 인해 [초기화](#초기화) 이전인 상태에서 `console.log()`가 변수 a에 접근
    - 즉, <u>변수 a가 가리키는 값</u>을 저장할 공간을 메모리에 확보하기 이전에 a를 참조했기 때문에 위의 에러가 발생한다.

<br>

### `var`과 `let`

| 선언 방법 | 선언 시 발생과정 |
| -------- | --------------- |
|    var   | 선언 및 `undefined`로 초기화 → 할당 |
|    let, const   | 선언 → **TDZ** → 초기화 → 할당 |

<br>
 
### 선언
변수를 실행 컨텍스트(Execution Context)에 등록하는 것

<br>

### TDZ
- Temporal Dead Zone(일시적 사각지대)
- 변수 선언과 초기화가 동시에 일어나는 것을 방지

<br>

### 초기화
- 메모리에 할당하는 것(변수가 가리키는 값을 저장할 공간 확보)
- JS에서는 모든 변수를 undefined로 초기화한다.

<br>

---

<br>

## 2. 화살표함수와 기본 매개변수

### 화살표 함수
- JS에서는 생성자함수로 사용 불가
- arguments(인수) 지원 안 함
- 함수를 보다 깔끔하게 처리

<br>

```
//before - ES5
function a(){
    return 1
}
console.log(a())  // 1
```
```
//after - ES6
const a_ES6 = () => 1
console.log(a_ES6())  // 1
```
function과 return이 사라진 모습

<br>

또 다른 예
```
const a = () => {
    //한 줄 이상의 로직
    return 1
}
console.log(a())  // 1
```
함수 로직이 한 줄 이상이라면
- {} 안에다 로직 구현
- return {반환 값}으로 마무리
    - 이렇게 습관화하는 것이 좋다. 후에 디버깅, 메서드체이닝, 함수합성 시 편리하다.

<br>

화살표함수로 setTimeout 등을 선언하면 당시 this가 함수호출 패턴에 의해 결정되는 것을 막을 수 있다.
```
function arrow(){
    setTimeout(() => {
        console.log(this) // arrow {}
    }, 1000)
}
function not_arrow(){
    setTimeout(function(){
        console.log(this) // Node.js에서는 Timeout || 브라우저에서는 Window    
    }, 1000)
}
const p1 = new not_arrow()
const p2 = new arrow()
```
- 화살표함수가 아닌 함수에서 this는 timeout이나 window를 가리킨다.
    - setTimeout 함수는 window 함수로, 브라우저의 백그라운드 공간으로 들어가 실행되는데 여기서 this는 이 함수가 호출된 곳에 바인딩되기 때문이다. 
- 화살표함수에서 this는 그 위의 생성자함수를 가리킨다.

<br>


### 기본 매개변수
```
const a = (b = 2) => {
    return b
}
console.log(a())  //2
```
기본 매개변수
- 함수 정의 시 바로 설정하는 기본적인 매개변수

<br>

---

<br>

## 3. 배열 관련 대표 함수
### forEach, map, filter, reduce
#### forEach
- 배열 요소 각각에 변경 등의 작업을 할 때 사용
- (map, filter, reduce 함수보다 뛰어남)

#### map
- 기존 배열로 **새로운** 배열 생성

#### filter
- 배열에서 **조건**에 맞는 원소를 추려서 새로운 배열 생성

#### reduce
- 배열을 통해 **하나의 계산된 값**(computed result)을 추출 

<br>

#### 예제
```
const func1 = (e, index) => {
    console.log(`${index}번째 요소는 ${e}입니다.`)
}
const func2 = (e, index) => e * 2
const func3 = (prev, curr, index) => prev + curr
const func4 = e => e % 2
const a = [1, 2, 3, 4, 5].forEach(func1)
/*
a에 forEach의 연산 값을 할당하는 과정에서 출력되는 결과
0번째 요소는 1입니다.
1번째 요소는 2입니다.
2번째 요소는 3입니다.
3번째 요소는 4입니다.
4번째 요소는 5입니다.
*/
console.log(a) // undefined

const b = [1, 2, 3, 4, 5].map(fun2)
console.log(b) // [ 2, 4, 6, 8, 10 ]

const c = [1, 2, 3, 4, 5].reduce(fucn3)
console.log(c) // 15

const d = [1, 2, 3, 4, 5].filter(func4)
console.log(d) // [ 1, 3, 5 ]
```
- forEach는 값을 반환하지 않는다.
- map: 새로운 배열 [2, 4, 6, 8, 10]을 반환한다.
- filter: 특정 조건, 즉 2로 나눈 나머지가 true(=1)인 요소만 추출한 배열을 반환한다.

<br>

>Note
>- filter는 특정 조건에 따라 요소를 추출할 수 있지만, 각 요소에 영향을 줄 수는 없다.
>- forEach는 반환값이 없다.

