
# 자바스크립트(Javascript)
실시간 모니터링 시스템을 만들며 정복하는 MEVN의 2장을 참고하여 용어별로 정리한 내용

## 목차

 
---

### 자바스크립트
- 인터프리터 기반의 동적 타입 언어
- 매년 발전 과정을 ES2015(ES6), ES2016(ES7) 등의 명칭으로 지정
    - ES6: ES2015 이후의 자바스크립트 문법
### ECMA
> ECMA 스크립트:<br>
ECMA-262 기술규격에 따라 정의하는 표준화된 스크립트 프로그래밍 언어. 자바스크립트 표준화 목적으로 제정<br>

<br>

### `var` 변수 선언
```
function b(){
    var i = 3;
    for(var i = 0; i < 10; i++){
    }
    return i;
}
console.log(b())    // 10
```
→ for문 안에서 var로 선언한 i는 함수 b()에서만 접근 가능(함수 [스코프](#스코프))<br>
→ 미리 선언된 i를 재할당한 셈이다.([호이스팅](#호이스팅) 때문)<br>
→ 3이 아닌 10을 반환<br><br>

```
function b(){
    for(var i = 0; i < 10; i++){
    // var로 선언 → 함수 스코프 → b() 함수의 최상단으로 호이스팅
    }
    return i;
    // 따라서 for문 안의 i를 블록 밖에서 참조 가능
}
console.log(b())    // 10
```
<br>

### `let` 변수 / `const` 상수 선언
```
    function b() {
        for(let i = 0; i < 10; i++){
        }
        return i;
    }
    console.log(b()) // Reference Error: i is not defined
```
let 변수 선언 → 블록 스코프, {} 안에서만 접근 가능<br>
<br>

### 스코프
변수의 접근성을 책임지는 보호막

- `var`로 변수 선언하면 함수 안에서 접근 가능 (함수 스코프)
- `let`, `const`로 선언하면 블록{} 안에서 접근 가능 (블록 스코프)

<br>

### 호이스팅
모든 함수, 변수가 선언될 때 스코프의 최상단으로 이동하는 것

<br>

#### const, let의 호이스팅
const, let으로 선언해도 호이스팅은 일어난다.<br>
```
let a = 1;
if(true){
    console.log(a)
    let a = 2
}
```
**Uncaught ReferenceError: Cannot access 'a' before initialization**
- 호이스팅이 일어나, `let a = 2`이 if 블록 최상단에서 선언된 것처럼 동작한다.
- [TDZ](#tdz)이 [선언](#선언)과 [초기화](#초기화)가 동시에 일어나는 것을 방지(`var`과 다른 점)<br>
<br>

### `var` vs. `let, const`
ES5에서는 `var`로 변수 선언 → 함수 스코프, 호이스팅으로 인해 버그 발생
- 이러한 이유로 ES6에서는 상수, 변수를 각각 `const`, `let` 키워드로 선언한다.<br>

| 선언 방법 | 선언 시 발생과정 |
| -------- | --------------- |
|    var   | 선언 및 초기화(undefined로) →   할당 |
|    let, const   | 선언 → TDZ →     할당 |

<br>

### 선언
변수를 실행 컨텍스트(Execution Context)에 등록하는 것

<br>

### TDZ
- Temporal Dead Zone(일시적 사각지대)
- 변수 선언 이후 초기화가 이루어지기까지의 구간

<br>

### 초기화
- 메모리에 할당하는 것(변수가 가리키는 값을 저장할 공간 확보)
- JS에서는 모든 변수를 undefined로 초기화한다.

<br>







